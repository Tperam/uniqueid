20220510

把这玩意想简单了，现在碰到一堆问题。

对于无锁的ringbuffer，我们需要考虑，我们怎么往里面添加数据与怎么从里面取数据。

最开始的想法是通过两个指针来进行使用。

- head 消费者（消费位置）
- tail 生产者（已生产值）

最好的方式就是如下代码。

```go
newHead := atomic.AddUint64(&rb.head,1)
if newHead < rb.tail {
    return rb.buffer[newHead&rb.mask]
}
```

但是这里会出现问题

- 当生产者跟不上消费者速度时，我们怎么使用阻塞？
- 由于我们是直接 `atomic.AddUint64` 预消费，生产者怎么知道消费者到底消费到哪里了？



以上问题暂时没有什么好思路解决

所以我将预消费，通过cas改成已消费，并且将等待用chan实现

```go
for {
    head := rb.head
    if head < rb.tail {
        result := rb.buffer[head&rb.mask]
        if atomic.CompareAndSwapUint64(&rb.head, head, head+1) {
            return result
        } else {
            continue
        }
    }
    <-rb.notice

}
```

但在 100w goroutine下，性能表现还是不尽人意。

- cas+chan 15.36s
- 纯锁 15.62s
  - 实现可能稍微有点不合理
- 纯chan 6.21

并没有达到我们实现ringbuffer的意义。



从此处