当前碰到的Bug就是在Fill填充buffer时，碰到正在消费的指针时会在越过该指针，不进行填充。导致在第二轮访问该区间时获取到已被消费的值。



那在这里触发的条件就是 当前最小消费指针的位置，会在本次填充时碰到
`(minConsumeCursor & bufferMask) < nextProduceCursor & bufferMask`
   - 也就是出现从上一轮末尾，填充到下一轮开头时，生产者指针与最低消费者指针碰头。
   - 由于go不是公平调度所导致个别goroutine消费过慢，很容易出现个别消费者还在1，而最新消费者已到9999。


解决方式
- 当上面条件触发时，生产者阻塞(cas,sleep)等待该消费者消费完毕
- 本次只填充到该生产者阻塞位置