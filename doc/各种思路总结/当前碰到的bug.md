
当前碰到的Bug就是在Fill填充buffer时，碰到正在消费的指针时会在越过该指针，不进行填充。导致在第二轮访问该区间时获取到已被消费的值。



那在这里触发的条件就是 当前最小消费指针的位置，会在本次填充时碰到
`(minConsumeCursor & bufferMask) < nextProduceCursor & bufferMask`
   - 也就是出现从上一轮末尾，填充到下一轮开头时，生产者指针与最低消费者指针碰头。
   - 由于go不是公平调度所导致个别goroutine消费过慢，很容易出现个别消费者还在1，而最新消费者已到9999。


解决方式
- 当上面条件触发时，生产者阻塞(cas,sleep)等待该消费者消费完毕
- 本次只填充到该生产者阻塞位置


### 发现当前版本具体BUG

假设我们现在两个go一直运行，总请求1w
根据我们的逻辑，这两个go 会平均分配该请求,A 拿到 5000个，B拿到5000个。
由于不公平调度，导致出现B已经在处理第9999个请求了，A线程可能还在处理第1000个请求。

这就导致内部取的消费者指针不均衡。

-> B 已经在处理第9999个去请求，可他的消费指针在6000

-> A 在处理第1000个请求，消费指针也在6000

这时就会出现，B已经完成了他所需要处理的所有任务并且停止运行了，但A还在慢慢转
这就导致了B的消费指针一直卡在6000，但A的消费指针一直递增，直到超出buffer长度，使得数据无法被填充