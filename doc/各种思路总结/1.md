disruptor 原理



1. 是一个 ringBuffer，重复利用同一片空间
2. 根据预先设定的消费者数量，生成消费指针
   - writer1,writer2,writer3,writer4
3. 填充时从上次填充下标填充到最小的writer指针（防止被消耗）



如果我们想让我们的id套入disruptor，那我们就必须确定并控制其消费者数量，由于我们在一定时间内会打入大量请求，所以我们需要在这中间修改内容。

如果从一个确定消费者数量模型，转换到不确定消费者数量模型，那我们这里肯定会产生数据竞争。

> 假设你有1024个消费者，然而可能在同一时间内，会打入1w个请求。那这时就会出现1w个请求，根据规则去抢占这1024个消费者，那这里必然产生数据竞争。

既然产生了数据竞争，那肯定少不了同步处理。

同步处理有

- 锁
- cas

cas不适合大量线程执行，仅适合较少线程运行，同时由于go语言特性，其 sync.Mutex 有一个锁升级的过程，所以具体逻辑我们暂时不管。

再根据chan的原理进行评估，本轮优化是否有效

> FIFO，每次发送数据与接收数据，都会上锁



那么我们下来的逻辑

```go
type consume struct{
    mu sync.Mutex
    writeIndex int64
}

type ringBuffer struct{
    buffer []uint64
    
    con []consume
}
```



根据 `atomic.add`方法，为每一个请求申请一个`id`

1. 根据id进行取余（&），分配到不同的格子中



